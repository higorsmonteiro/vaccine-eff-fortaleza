'''
    After data is prepared, apply the cohort conditions and the matching process.

    The data generated by this class are composed by two files:
        - Table of pairs with the date of the events of interest.
        - Table containing general information of all individuals considered for 
        the matching process (the individuals in the first table forms a subset of
        this table).
'''
import numpy as np
import pandas as pd
import datetime as dt
from tqdm import tqdm
import lib.aux_utils as aux
import lib.utils as utils
import lib.matching_utils as matching_utils
from collections import defaultdict
from dateutil.relativedelta import relativedelta

col_tests = ["Data da Solicitação(GAL)", "Data da Coleta(GAL)"]

class DefineCohortSettings:
    def __init__(self, vacineja_df, init_cohort, final_cohort):
        '''
            Description.

            Args:
                vacineja_df:
                    pandas.DataFrame.
                init_cohort:
                    datetime.date.
                final_cohort:
                    datetime.date.
        '''
        self.vacineja_df = vacineja_df.copy()
        self.init_cohort = init_cohort
        self.final_cohort = final_cohort

    def define_eligibility(self, partial=14, fully=14, return_=True):
        '''
            Define new columns in the 'Vacine Já' database regarding the eligibility criteria to an individual
            be part of the cohort.

            Args:
                partial:
                    Integer.
                fully:
                    Integer.
                return_:
                    Bool.
            Return:
                self.vacineja_df. If return_=True. 
        '''
        subset = ["data D1(VACINADOS)", "data D2(VACINADOS)"]
        self.vacineja_df["VACINA STATUS - COORTE"] = self.vacineja_df[subset].apply(lambda x: aux.f_when_vaccine(x, self.init_cohort, self.final_cohort), axis=1)
        self.vacineja_df["IMUNIZACAO MAXIMA ATE FIM DA COORTE"] = self.vacineja_df[subset].apply(lambda x: aux.f_immunization(x, self.init_cohort, self.final_cohort, partial, fully), axis=1)

        # --> Eligibility by tests
        subset = ["Data da Solicitação(GAL)", "Data da Coleta(GAL)", "RESULTADO FINAL GAL-INTEGRASUS"]
        self.vacineja_df["ELIGIBILIDADE TESTE"] = self.vacineja_df[subset].apply(lambda x: aux.f_eligible_test(x, self.init_cohort, self.final_cohort), axis=1)
        
        subset = "IMUNIZACAO MAXIMA ATE FIM DA COORTE"
        aptos = ["NAO VACINADO", "PARCIALMENTE IMUNIZADO", "TOTALMENTE IMUNIZADO", "VACINADO SEM IMUNIZACAO"]
        self.vacineja_df["ELIGIBILIDADE COORTE GERAL"] = self.vacineja_df[subset].apply(lambda x: "APTO" if x in aptos else "NAO APTO")
        # --> Eligibility for cases partial
        self.vacineja_df["ELIGIBILIDADE EXPOSTO PARCIAL"] = self.vacineja_df[subset].apply(lambda x: "APTO" if x=="PARCIALMENTE IMUNIZADO" else "NAO APTO")
        # --> Eligibility for cases fully
        self.vacineja_df["ELIGIBILIDADE EXPOSTO TOTAL"] = self.vacineja_df[subset].apply(lambda x: "APTO" if x=="TOTALMENTE IMUNIZADO" else "NAO APTO")
        # --> Create column with age based on the final of cohort.
        self.vacineja_df["idade"] = self.vacineja_df["data_nascimento"].apply(lambda x: relativedelta(self.final_cohort, x.date()).years)
        self.vacineja_df = self.vacineja_df.drop_duplicates(subset=["cpf"], keep="first")

        if return_:
            return self.vacineja_df

    def dynamical_matching(self, vaccine="CORONAVAC", age_thr=18, verbose=False, seed=0):
        '''
            Perform the matching mechanism to find the case-control pairs.

            After selecting all individuals who took the specified vaccine at a day during cohort, we find
            for each day all possible controls for the cases. Matching is performed using sex and age variables.

            Args:
                vaccine:
                    String. {"CORONAVAC", "ASTRAZENECA", "PFIZER"}. Vaccine to consider during matching for
                    the cases. 
                age_thr:
                    Integer. Minimum age to consider during matching.
                verbose:
                    Bool.
                seed:
                    Integer. Random seed to change the order of possible control candidates.
                final_cohort:
                    datetime.date.
            Return:
                events_df:
                df_pop:

        '''
        if "ELIGIBILIDADE TESTE" not in self.vacineja_df.columns:
            return -1

        datelst = utils.generate_date_list(self.init_cohort, self.final_cohort)
        
        # --> APPLY ESSENTIAL FILTERS
        # First, consider only people with age older or equal to 'age_thr' years old.
        df = self.vacineja_df[self.vacineja_df["idade"]>=age_thr]
        df = df[(df["OBITO INCONSISTENCIA COVID"]!="S") & (df["OBITO INCONSISTENCIA CARTORIOS"]!="S")]
        df = df[df["data aplicacao consistente(VACINADOS)"]!="N"]
        # Filter by eligibility
        df = df[(df["ELIGIBILIDADE TESTE"]=="APTO") & (df["ELIGIBILIDADE COORTE GERAL"]=="APTO")]
        # Obtain set of vaccinated and unvaccinated individuals.
        df_vaccinated = df[df["vacina(VACINADOS)"]==vaccine].dropna(subset=["data D1(VACINADOS)"], axis=0)
        df_unvaccinated = df[pd.isna(df["vacina(VACINADOS)"])]
        
        if verbose:
            print(f"Dimensão de elegíveis após aplicacão das condições: {df.shape}")
            print(f"Número restante de óbitos: {df['data_obito(OBITO COVID)'].notnull().sum()}")
            #print(f"Número restante de hospitalizados: {df['DATA HOSPITALIZACAO'].notnull().sum()}")
            #print(f"Número restante de testes: {df['DATA SOLICITACAO(TESTES)'].notnull().sum()}")
            print(f"Número de vacinados elegíveis para {vaccine}: {df_vaccinated.shape[0]}")

        # -- CREATE CONTROL RESERVOIR --
        control_used = defaultdict(lambda: False)
        control_reservoir = defaultdict(lambda:[])
        control_dates = {
            "D1": defaultdict(lambda:-1),
            "D2": defaultdict(lambda:-1),
            "DEATH COVID": defaultdict(lambda:-1),
            "DEATH GENERAL": defaultdict(lambda:-1)
        }
        df_pop = pd.concat([df_vaccinated, df_unvaccinated])
        if verbose: print("Criando reservatório de controles ...")
        # Get the main outcomes' dates for each eligible individual of the cohort.
        col_names = {
            "D1": "data D1(VACINADOS)",
            "D2": "data D2(VACINADOS)",
            "OBITO COVID": "data_obito(OBITO COVID)",
            "OBITO GERAL": "data falecimento(CARTORIOS)"
        }
        print("Coletando datas para toda população considerada ...")
        matching_utils.collect_dates_for_cohort(df_pop, control_reservoir, control_dates, col_names)
        print("Coletando datas para toda população considerada ... Concluído.")
        matching_utils.rearrange_controls(control_reservoir, seed)
        print("Executando pareamento ...")
        pareados, matched = matching_utils.perform_matching(datelst, df_vaccinated, control_reservoir, control_used, control_dates, col_names)
        print("Executando pareamento ... Concluído.")
        
        events_df = matching_utils.get_events(df_pop, pareados, matched, col_names)
        df_pop["PAREADO"] = df_pop["cpf"].apply(lambda x: "SIM" if matched[x] else "NAO")

        return events_df, df_pop